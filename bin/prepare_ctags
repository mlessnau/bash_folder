#!/usr/bin/env ruby

require 'optparse'

CTAGS_GEMS_DIR = 'ctags_gems'

options = {}

option_parser = OptionParser.new do |o|
  o.banner = "Usage: #{File.basename(__FILE__, '.rb')} [options]\n\n"

  o.on('-f', '--full', 'Runs bundle install and recreates gem symlinks') do
    options[:full] = true
  end

  o.on('-h', '--help', 'Show help') do
    puts o
    exit 0
  end
end

begin
  option_parser.parse! ARGV
rescue OptionParser::InvalidOption => e
  puts e
  puts option_parser
  exit 1
end

gems = {}

if options[:full]
  print 'Running bundle install ...'
  `bundle install`
  rbenv = `which rbenv`.gsub(/^\s+|\s+$|\n/, '')
  `#{rbenv} rehash` if 0 < rbenv.length
  puts ' DONE'

  print 'Retrieving used gems ...'
  gem_names = `bundle list | grep '*' | tr -s ' ' ' ' | cut -d ' ' -f 3`.split("\n")
  puts " DONE (#{gem_names.size} gems)"

  print 'Retrieving gem locations '
  gem_names.each do |gem_name|
    print '.'
    gems[gem_name] = `bundle show #{gem_name}`.gsub(/^\s*|(\n|\s)+$/, '')
  end
  puts ' DONE'

  print 'Cleaning up gem symlinks ...'
  `rm -rf #{CTAGS_GEMS_DIR}`
  puts ' DONE'

  print 'Creating gem symlinks '
  `mkdir #{CTAGS_GEMS_DIR}`
  gems.each do |name, location|
    print '.'
    `ln -s #{location} #{CTAGS_GEMS_DIR}/#{name}`
  end
  puts ' DONE'
end

ruby_options = [
  '/(^|[:;])[ \\t]*([A-Z][[:alnum:]_]+) *=/\\2/c,class,constant/',
  '/(^|;)[ \\t]*(has_many|belongs_to|has_one|has_and_belongs_to_many)\\(? *:([[:alnum:]_]+)/\\3/f,function,association/',
  '/(^|;)[ \\t]*(named_)?scope\\(? *:([[:alnum:]_]+)/\\3/f,function,named_scope/',
  '/(^|;)[ \\t]*expose\\(? *:([[:alnum:]_]+)/\\2/f,function,exposure/',
  '/(^|;)[ \\t]*event\\(? *:([[:alnum:]_]+)/\\2/f,function,aasm_event/',
  '/(^|;)[ \\t]*event\\(? *:([[:alnum:]_]+)/\\2!/f,function,aasm_event/',
  '/(^|;)[ \\t]*event\\(? *:([[:alnum:]_]+)/\\2?/f,function,aasm_event/'
]

print 'Creating ctags database ...'
`rm -f tags`
`ctags -R --exclude=.git --exclude=log --regex-ruby='#{ruby_options.join("' --regex-ruby='")}' . &> /dev/null`
puts ' DONE'
